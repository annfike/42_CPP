#ifndef SCALARCONVERTER_HPP
#define SCALARCONVERTER_HPP

#include <iostream>
#include <cstdlib>
#include <cmath> 
#include <cfloat>
#include <climits>
#include <sstream>

class ScalarConverter
{
    private:
        ScalarConverter();
        ScalarConverter(ScalarConverter const &arg);
        ScalarConverter& operator=(ScalarConverter const &arg);
        ~ScalarConverter();
    public:
        static void convert(std::string input);
};

#endif

/*
1. static_cast
static_cast используется для выполнения явного преобразования типов, когда преобразование безопасно и 
может быть выполнено на этапе компиляции. Он подходит для:
Преобразования между связанными типами (например, от базового класса к производному и наоборот).
Преобразования между числовыми типами (например, int в float).Преобразования указателей и ссылок.
Пример использования:
int a = 10;
float b = static_cast<float>(a); // Преобразование int в float

2. dynamic_cast
dynamic_cast используется для безопасного приведения типов в иерархии классов, особенно когда вы работаете 
с полиморфизмом (классы с вирт. функциями). Он проверяет, является ли объект, на который указывает указатель или ссылка, 
действительно объектом производного класса. Если приведение невозможно, возвращает nullptr для указателей или вызывает исключение для ссылок.
Пример использования:
class Base { virtual void foo() {} };
class Derived : public Base {};

Base* b = new Derived();
Derived* d = dynamic_cast<Derived*>(b); // Безопасное приведение
if (d) {
    // Приведение успешно
}

3. const_cast
const_cast используется для добавления или удаления модификатора const у переменной. Это полезно, 
когда вам нужно изменить const-объект или передать его в функцию, которая не принимает const-аргументы.
Пример использования:
const int a = 10;
int* b = const_cast<int*>(&a); // Удаление const
*b = 20; // Это может привести к неопределенному поведению

4. reinterpret_cast
reinterpret_cast используется для выполнения низкоуровневого преобразования типов. 
Он позволяет преобразовывать указатели и ссылки между несовместимыми типами. Это может быть полезно, 
но требует осторожности, так как может привести к неопределенному поведению, если не использовать его правильно.
Пример использования:
int a = 10;
void* ptr = reinterpret_cast<void*>(&a); // Преобразование указателя int в void*

Заключение
Каждый из этих операторов приведения типов имеет свои особенности и предназначение. 
Используйте static_cast для обычных преобразований, dynamic_cast для безопасного приведения в иерархиях классов, 
const_cast для изменения const-свойств, и reinterpret_cast для низкоуровневых преобразований. Правильный выбор оператора поможет избежать ошибок и сделать код более безопасным и понятным.
*/